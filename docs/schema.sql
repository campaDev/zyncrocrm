-- -----------------------------------------------------------------------------
--  Zyncro CRM - Database Schema (PostgreSQL / Supabase)
-- Versi贸n: 1.0 (Basada en ZYNCRO_BLUEPRINT.md v1.3)
-- -----------------------------------------------------------------------------

-- 1. Configuraciones Iniciales y Extensiones
-- Habilitar extensi贸n para UUIDs si no est谩 activa
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- 2. Definici贸n de ENUMS (Tipos de datos personalizados)
CREATE TYPE user_role AS ENUM ('superuser', 'admin', 'seller');
CREATE TYPE user_status AS ENUM ('online', 'offline', 'busy');
CREATE TYPE channel_status AS ENUM ('connected', 'disconnected', 'error');
CREATE TYPE message_direction AS ENUM ('inbound', 'outbound');
CREATE TYPE message_type AS ENUM ('text', 'image', 'audio', 'video', 'document', 'location', 'template', 'note');
CREATE TYPE message_status AS ENUM ('sent', 'delivered', 'read', 'failed');
CREATE TYPE template_status AS ENUM ('approved', 'rejected', 'pending');

-- -----------------------------------------------------------------------------
-- 3. Creaci贸n de Tablas
-- -----------------------------------------------------------------------------

-- TABLA: PROFILES (Extiende auth.users)
-- Se vincula autom谩ticamente cuando un usuario se crea en Supabase Auth (requiere Trigger adicional, ver abajo)
CREATE TABLE public.profiles (
  id UUID REFERENCES auth.users(id) ON DELETE CASCADE PRIMARY KEY,
  email TEXT,
  full_name TEXT,
  role user_role DEFAULT 'seller',
  avatar_url TEXT,
  status user_status DEFAULT 'offline',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Habilitar RLS
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- TABLA: CHANNELS (L铆neas de WhatsApp)
CREATE TABLE public.channels (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  name TEXT NOT NULL, -- Ej: "Ventas Web"
  phone_number TEXT NOT NULL, -- Ej: "+54911..."
  meta_phone_id TEXT UNIQUE NOT NULL, -- ID de Meta
  default_assignee_id UUID REFERENCES public.profiles(id), -- Si es NULL, es compartido
  status channel_status DEFAULT 'disconnected',
  config JSONB DEFAULT '{}'::JSONB, -- Horarios y Auto-reply
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Habilitar RLS
ALTER TABLE public.channels ENABLE ROW LEVEL SECURITY;

-- TABLA: CONTACTS (Clientes)
CREATE TABLE public.contacts (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  channel_id UUID REFERENCES public.channels(id) ON DELETE CASCADE NOT NULL,
  phone_number TEXT NOT NULL,
  name TEXT DEFAULT 'Guest',
  assigned_to UUID REFERENCES public.profiles(id), -- NULL = Sin asignar
  unread_count INTEGER DEFAULT 0,
  last_interaction TIMESTAMPTZ DEFAULT NOW(),
  whatsapp_name TEXT,
  labels TEXT[] DEFAULT '{}', -- Array de etiquetas
  metadata JSONB DEFAULT '{}'::JSONB, -- Datos flexibles (Empresa, RUC, etc)
  created_at TIMESTAMPTZ DEFAULT NOW(),
  
  -- Restricci贸n: Un n煤mero es 煤nico PERO dentro de un mismo canal
  UNIQUE(phone_number, channel_id)
);

-- Habilitar RLS
ALTER TABLE public.contacts ENABLE ROW LEVEL SECURITY;

-- TABLA: MESSAGES (Historial)
CREATE TABLE public.messages (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  contact_id UUID REFERENCES public.contacts(id) ON DELETE CASCADE NOT NULL,
  sender_id UUID REFERENCES public.profiles(id), -- NULL si lo envi贸 el cliente
  reply_to_id BIGINT REFERENCES public.messages(id),
  direction message_direction NOT NULL,
  type message_type DEFAULT 'text',
  content TEXT,
  media_url TEXT,
  status message_status DEFAULT 'sent',
  wam_id TEXT UNIQUE, -- ID de mensaje de WhatsApp para evitar duplicados
  is_internal BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Habilitar RLS
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;

-- TABLA: TEMPLATES (Plantillas HSM)
CREATE TABLE public.templates (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  meta_id TEXT UNIQUE NOT NULL,
  name TEXT NOT NULL,
  body TEXT NOT NULL,
  language TEXT DEFAULT 'es',
  status template_status DEFAULT 'pending',
  created_at TIMESTAMPTZ DEFAULT NOW()
);

ALTER TABLE public.templates ENABLE ROW LEVEL SECURITY;

-- TABLA: SYSTEM_CONFIG (Solo Superuser)
CREATE TABLE public.system_config (
  key TEXT PRIMARY KEY,
  value TEXT NOT NULL,
  description TEXT
);

ALTER TABLE public.system_config ENABLE ROW LEVEL SECURITY;

-- TABLA: AUDIT_LOGS
CREATE TABLE public.audit_logs (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES public.profiles(id),
  action TEXT NOT NULL,
  details JSONB,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- -----------------------------------------------------------------------------
-- 4. Funciones y Triggers (Automatizaci贸n)
-- -----------------------------------------------------------------------------

-- Funci贸n: Actualizar last_interaction en Contacto cuando hay mensaje nuevo
CREATE OR REPLACE FUNCTION update_contact_interaction()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.contacts
  SET last_interaction = NOW(),
      -- Si el mensaje entra (inbound) y NO es interno, sumar 1 al unread_count
      unread_count = CASE 
        WHEN NEW.direction = 'inbound' THEN unread_count + 1 
        ELSE unread_count 
      END
  WHERE id = NEW.contact_id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER on_new_message
AFTER INSERT ON public.messages
FOR EACH ROW
EXECUTE FUNCTION update_contact_interaction();

-- Funci贸n: Manejar nuevo usuario (Crear perfil autom谩ticamente al registrarse)
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, role)
  VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data->>'full_name', 'seller');
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- -----------------------------------------------------------------------------
-- 5. Pol铆ticas de Seguridad (RLS Policies)
-- Definimos QUIN puede ver QU
-- -----------------------------------------------------------------------------

-- PROFILES:
-- Todos pueden ver perfiles (para mostrar nombre/foto en el chat)
CREATE POLICY "Profiles are viewable by everyone" ON public.profiles FOR SELECT USING (true);
-- Solo el usuario puede editar su propio estado/avatar (o un superuser)
CREATE POLICY "Users can update own profile" ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- CHANNELS:
-- Todos pueden ver los canales disponibles
CREATE POLICY "Channels viewable by authenticated" ON public.channels FOR SELECT TO authenticated USING (true);
-- Solo Superuser edita canales
CREATE POLICY "Superuser manages channels" ON public.channels FOR ALL USING (
  EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND role = 'superuser')
);

-- CONTACTS:
-- Super/Admin ven todo.
-- Sellers ven: 
-- 1. Sus asignados (assigned_to = me)
-- 2. Los de sus canales personales (channel.default_assignee = me)
-- 3. Los NO asignados en canales p煤blicos (assigned_to IS NULL AND channel.default_assignee IS NULL)
CREATE POLICY "Contacts visibility logic" ON public.contacts FOR SELECT TO authenticated USING (
  (SELECT role FROM public.profiles WHERE id = auth.uid()) IN ('superuser', 'admin')
  OR assigned_to = auth.uid()
  OR EXISTS (
      SELECT 1 FROM public.channels 
      WHERE id = contacts.channel_id 
      AND (default_assignee_id = auth.uid() OR (default_assignee_id IS NULL AND contacts.assigned_to IS NULL))
  )
);

-- MESSAGES:
-- Heredan la visibilidad del contacto. Si puedes ver el contacto, puedes ver sus mensajes.
CREATE POLICY "Messages inherited visibility" ON public.messages FOR SELECT TO authenticated USING (
  EXISTS (SELECT 1 FROM public.contacts WHERE id = messages.contact_id) -- Supabase aplica recursivamente la policy de contacts
);

-- Insertar mensajes: Todos los usuarios autenticados pueden enviar mensajes (el backend validar谩 l贸gica extra)
CREATE POLICY "Agents can insert messages" ON public.messages FOR INSERT TO authenticated WITH CHECK (true);
